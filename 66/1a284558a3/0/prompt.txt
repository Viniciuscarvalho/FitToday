Eu possuo essas issues referente a bugs e redesign de telas, https://github.com/Viniciuscarvalho/FitToday/issues, al√©m de verificar uma melhor maneira de mostrar a descri√ß√£o do treino que est√° mesclado tanto em portugu√™s como ingl√™s para todos os exerc√≠cios dos programas e os que est√£o sendo gerados pela IA tamb√©m, isso est√° confundindo o usu√°rio e n√£o est√° sendo uma boa experi√™ncia para lan√ßar o app em produ√ß√£o. Utilize as skills /swiftui-expert-skill e /feature-marker ‚Äîinteractive -prd-bugfix-descriptionExercices

---

Base directory for this skill: /Users/viniciuscarvalho/.claude/skills/swiftui-expert-skill

# SwiftUI Expert Skill

## Overview
Use this skill to build, review, or improve SwiftUI features with correct state management, modern API usage, Swift concurrency best practices, optimal view composition, and iOS 26+ Liquid Glass styling. Prioritize native APIs, Apple design guidance, and performance-conscious patterns. This skill focuses on facts and best practices without enforcing specific architectural patterns.

## Workflow Decision Tree

### 1) Review existing SwiftUI code
- Check property wrapper usage against the selection guide (see `references/state-management.md`)
- Verify modern API usage (see `references/modern-apis.md`)
- Verify view composition follows extraction rules (see `references/view-structure.md`)
- Check performance patterns are applied (see `references/performance-patterns.md`)
- Verify list patterns use stable identity (see `references/list-patterns.md`)
- Inspect Liquid Glass usage for correctness and consistency (see `references/liquid-glass.md`)
- Validate iOS 26+ availability handling with sensible fallbacks

### 2) Improve existing SwiftUI code
- Audit state management for correct wrapper selection (prefer `@Observable` over `ObservableObject`)
- Replace deprecated APIs with modern equivalents (see `references/modern-apis.md`)
- Extract complex views into separate subviews (see `references/view-structure.md`)
- Refactor hot paths to minimize redundant state updates (see `references/performance-patterns.md`)
- Ensure ForEach uses stable identity (see `references/list-patterns.md`)
- Suggest image downsampling when `UIImage(data:)` is used (as optional optimization, see `references/image-optimization.md`)
- Adopt Liquid Glass only when explicitly requested by the user

### 3) Implement new SwiftUI feature
- Design data flow first: identify owned vs injected state (see `references/state-management.md`)
- Use modern APIs (no deprecated modifiers or patterns, see `references/modern-apis.md`)
- Use `@Observable` for shared state (with `@MainActor` if not using default actor isolation)
- Structure views for optimal diffing (extract subviews early, keep views small, see `references/view-structure.md`)
- Separate business logic into testable models (see `references/layout-best-practices.md`)
- Apply glass effects after layout/appearance modifiers (see `references/liquid-glass.md`)
- Gate iOS 26+ features with `#available` and provide fallbacks

## Core Guidelines

### State Management
- **Always prefer `@Observable` over `ObservableObject`** for new code
- **Mark `@Observable` classes with `@MainActor`** unless using default actor isolation
- **Always mark `@State` and `@StateObject` as `private`** (makes dependencies clear)
- **Never declare passed values as `@State` or `@StateObject`** (they only accept initial values)
- Use `@State` with `@Observable` classes (not `@StateObject`)
- `@Binding` only when child needs to **modify** parent state
- `@Bindable` for injected `@Observable` objects needing bindings
- Use `let` for read-only values; `var` + `.onChange()` for reactive reads
- Legacy: `@StateObject` for owned `ObservableObject`; `@ObservedObject` for injected
- Nested `ObservableObject` doesn't work (pass nested objects directly); `@Observable` handles nesting fine

### Modern APIs
- Use `foregroundStyle()` instead of `foregroundColor()`
- Use `clipShape(.rect(cornerRadius:))` instead of `cornerRadius()`
- Use `Tab` API instead of `tabItem()`
- Use `Button` instead of `onTapGesture()` (unless need location/count)
- Use `NavigationStack` instead of `NavigationView`
- Use `navigationDestination(for:)` for type-safe navigation
- Use two-parameter or no-parameter `onChange()` variant
- Use `ImageRenderer` for rendering SwiftUI views
- Use `.sheet(item:)` instead of `.sheet(isPresented:)` for model-based content
- Sheets should own their actions and call `dismiss()` internally
- Use `ScrollViewReader` for programmatic scrolling with stable IDs
- Avoid `UIScreen.main.bounds` for sizing
- Avoid `GeometryReader` when alternatives exist (e.g., `containerRelativeFrame()`)

### Swift Best Practices
- Use modern Text formatting (`.format` parameters, not `String(format:)`)
- Use `localizedStandardContains()` for user-input filtering (not `contains()`)
- Prefer static member lookup (`.blue` vs `Color.blue`)
- Use `.task` modifier for automatic cancellation of async work
- Use `.task(id:)` for value-dependent tasks

### View Composition
- **Prefer modifiers over conditional views** for state changes (maintains view identity)
- Extract complex views into separate subviews for better readability and performance
- Keep views small for optimal performance
- Keep view `body` simple and pure (no side effects or complex logic)
- Use `@ViewBuilder` functions only for small, simple sections
- Prefer `@ViewBuilder let content: Content` over closure-based content properties
- Separate business logic into testable models (not about enforcing architectures)
- Action handlers should reference methods, not contain inline logic
- Use relative layout over hard-coded constants
- Views should work in any context (don't assume screen size or presentation style)

### Performance
- Pass only needed values to views (avoid large "config" or "context" objects)
- Eliminate unnecessary dependencies to reduce update fan-out
- Check for value changes before assigning state in hot paths
- Avoid redundant state updates in `onReceive`, `onChange`, scroll handlers
- Minimize work in frequently executed code paths
- Use `LazyVStack`/`LazyHStack` for large lists
- Use stable identity for `ForEach` (never `.indices` for dynamic content)
- Ensure constant number of views per `ForEach` element
- Avoid inline filtering in `ForEach` (prefilter and cache)
- Avoid `AnyView` in list rows
- Consider POD views for fast diffing (or wrap expensive views in POD parents)
- Suggest image downsampling when `UIImage(data:)` is encountered (as optional optimization)
- Avoid layout thrash (deep hierarchies, excessive `GeometryReader`)
- Gate frequent geometry updates by thresholds
- Use `Self._printChanges()` to debug unexpected view updates

### Liquid Glass (iOS 26+)
**Only adopt when explicitly requested by the user.**
- Use native `glassEffect`, `GlassEffectContainer`, and glass button styles
- Wrap multiple glass elements in `GlassEffectContainer`
- Apply `.glassEffect()` after layout and visual modifiers
- Use `.interactive()` only for tappable/focusable elements
- Use `glassEffectID` with `@Namespace` for morphing transitions

## Quick Reference

### Property Wrapper Selection (Modern)
| Wrapper | Use When |
|---------|----------|
| `@State` | Internal view state (must be `private`), or owned `@Observable` class |
| `@Binding` | Child modifies parent's state |
| `@Bindable` | Injected `@Observable` needing bindings |
| `let` | Read-only value from parent |
| `var` | Read-only value watched via `.onChange()` |

**Legacy (Pre-iOS 17):**
| Wrapper | Use When |
|---------|----------|
| `@StateObject` | View owns an `ObservableObject` (use `@State` with `@Observable` instead) |
| `@ObservedObject` | View receives an `ObservableObject` |

### Modern API Replacements
| Deprecated | Modern Alternative |
|------------|-------------------|
| `foregroundColor()` | `foregroundStyle()` |
| `cornerRadius()` | `clipShape(.rect(cornerRadius:))` |
| `tabItem()` | `Tab` API |
| `onTapGesture()` | `Button` (unless need location/count) |
| `NavigationView` | `NavigationStack` |
| `onChange(of:) { value in }` | `onChange(of:) { old, new in }` or `onChange(of:) { }` |
| `fontWeight(.bold)` | `bold()` |
| `GeometryReader` | `containerRelativeFrame()` or `visualEffect()` |
| `showsIndicators: false` | `.scrollIndicators(.hidden)` |
| `String(format: "%.2f", value)` | `Text(value, format: .number.precision(.fractionLength(2)))` |
| `string.contains(search)` | `string.localizedStandardContains(search)` (for user input) |

### Liquid Glass Patterns
```swift
// Basic glass effect with fallback
if #available(iOS 26, *) {
    content
        .padding()
        .glassEffect(.regular.interactive(), in: .rect(cornerRadius: 16))
} else {
    content
        .padding()
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))
}

// Grouped glass elements
GlassEffectContainer(spacing: 24) {
    HStack(spacing: 24) {
        GlassButton1()
        GlassButton2()
    }
}

// Glass buttons
Button("Confirm") { }
    .buttonStyle(.glassProminent)
```

## Review Checklist

### State Management
- [ ] Using `@Observable` instead of `ObservableObject` for new code
- [ ] `@Observable` classes marked with `@MainActor` (if needed)
- [ ] Using `@State` with `@Observable` classes (not `@StateObject`)
- [ ] `@State` and `@StateObject` properties are `private`
- [ ] Passed values NOT declared as `@State` or `@StateObject`
- [ ] `@Binding` only where child modifies parent state
- [ ] `@Bindable` for injected `@Observable` needing bindings
- [ ] Nested `ObservableObject` avoided (or passed directly to child views)

### Modern APIs (see `references/modern-apis.md`)
- [ ] Using `foregroundStyle()` instead of `foregroundColor()`
- [ ] Using `clipShape(.rect(cornerRadius:))` instead of `cornerRadius()`
- [ ] Using `Tab` API instead of `tabItem()`
- [ ] Using `Button` instead of `onTapGesture()` (unless need location/count)
- [ ] Using `NavigationStack` instead of `NavigationView`
- [ ] Avoiding `UIScreen.main.bounds`
- [ ] Using alternatives to `GeometryReader` when possible
- [ ] Button images include text labels for accessibility

### Sheets & Navigation (see `references/sheet-navigation-patterns.md`)
- [ ] Using `.sheet(item:)` for model-based sheets
- [ ] Sheets own their actions and dismiss internally
- [ ] Using `navigationDestination(for:)` for type-safe navigation

### ScrollView (see `references/scroll-patterns.md`)
- [ ] Using `ScrollViewReader` with stable IDs for programmatic scrolling
- [ ] Using `.scrollIndicators(.hidden)` instead of initializer parameter

### Text & Formatting (see `references/text-formatting.md`)
- [ ] Using modern Text formatting (not `String(format:)`)
- [ ] Using `localizedStandardContains()` for search filtering

### View Structure (see `references/view-structure.md`)
- [ ] Using modifiers instead of conditionals for state changes
- [ ] Complex views extracted to separate subviews
- [ ] Views kept small for performance
- [ ] Container views use `@ViewBuilder let content: Content`

### Performance (see `references/performance-patterns.md`)
- [ ] View `body` kept simple and pure (no side effects)
- [ ] Passing only needed values (not large config objects)
- [ ] Eliminating unnecessary dependencies
- [ ] State updates check for value changes before assigning
- [ ] Hot paths minimize state updates
- [ ] No object creation in `body`
- [ ] Heavy computation moved out of `body`

### List Patterns (see `references/list-patterns.md`)
- [ ] ForEach uses stable identity (not `.indices`)
- [ ] Constant number of views per ForEach element
- [ ] No inline filtering in ForEach
- [ ] No `AnyView` in list rows

### Layout (see `references/layout-best-practices.md`)
- [ ] Avoiding layout thrash (deep hierarchies, excessive GeometryReader)
- [ ] Gating frequent geometry updates by thresholds
- [ ] Business logic separated into testable models
- [ ] Action handlers reference methods (not inline logic)
- [ ] Using relative layout (not hard-coded constants)
- [ ] Views work in any context (context-agnostic)

### Liquid Glass (iOS 26+)
- [ ] `#available(iOS 26, *)` with fallback for Liquid Glass
- [ ] Multiple glass views wrapped in `GlassEffectContainer`
- [ ] `.glassEffect()` applied after layout/appearance modifiers
- [ ] `.interactive()` only on user-interactable elements
- [ ] Shapes and tints consistent across related elements

## References
- `references/state-management.md` - Property wrappers and data flow (prefer `@Observable`)
- `references/view-structure.md` - View composition, extraction, and container patterns
- `references/performance-patterns.md` - Performance optimization techniques and anti-patterns
- `references/list-patterns.md` - ForEach identity, stability, and list best practices
- `references/layout-best-practices.md` - Layout patterns, context-agnostic views, and testability
- `references/modern-apis.md` - Modern API usage and deprecated replacements
- `references/sheet-navigation-patterns.md` - Sheet presentation and navigation patterns
- `references/scroll-patterns.md` - ScrollView patterns and programmatic scrolling
- `references/text-formatting.md` - Modern text formatting and string operations
- `references/image-optimization.md` - AsyncImage, image downsampling, and optimization
- `references/liquid-glass.md` - iOS 26+ Liquid Glass API

## Philosophy

This skill focuses on **facts and best practices**, not architectural opinions:
- We don't enforce specific architectures (e.g., MVVM, VIPER)
- We do encourage separating business logic for testability
- We prioritize modern APIs over deprecated ones
- We emphasize thread safety with `@MainActor` and `@Observable`
- We optimize for performance and maintainability
- We follow Apple's Human Interface Guidelines and API design patterns

---

Base directory for this skill: /Users/viniciuscarvalho/.claude/skills/feature-marker

# feature-marker

Automates feature development with a 5-phase workflow:

1. **Inputs Gate** - Validates `prd.md`, `techspec.md`, `tasks.md` exist; generates them via `~/.claude/commands/` if missing.
2. **Analysis & Planning** - Auto-installs product-manager skill if missing; reads docs, creates implementation plan.
3. **Implementation** - Executes tasks with progress tracking.
4. **Tests & Validation** - Runs test suites, validates build, and runs iOS simulator (XcodeBuildMCP) if available.
5. **Commit & PR** - Auto-installs enhanced commit command if missing; commits changes using professional workflow and creates PR (auto-detects git platform).

## Usage

```
/feature-marker <feature-slug>
```

**Example**:
```
/feature-marker prd-user-authentication
```

### Interactive Mode

```
/feature-marker --interactive <feature-slug>
```

Opens a menu to select execution mode:
- **Full Workflow** - Default, generates missing files and executes all phases
- **Tasks Only** - Uses existing files, skips generation phase
- **Ralph Loop** - Autonomous continuous execution with ralph-wiggum
- **Spec-Driven** - Multi-agent review + worktree isolation via spec-workflow

Works both in terminal (TTY menu) and Claude CLI (AskUserQuestion prompt).

**Direct mode selection** (skip menu):
```
/feature-marker --mode full <feature-slug>
/feature-marker --mode tasks-only <feature-slug>
/feature-marker --mode ralph-loop <feature-slug>
/feature-marker --mode spec-driven <feature-slug>
```

## Prerequisites

### Commands

The following commands must be available in `~/.claude/commands/`:

- `create-prd.md` - Creates a new PRD from requirements discussion
- `generate-spec.md` - Generates technical specification from PRD
- `generate-tasks.md` - Breaks down feature spec into implementable tasks

### Templates

The commands above read templates from `~/.claude/docs/specs/` to generate structured documents.

Required templates:
- `~/.claude/docs/specs/prd-template.md` - Product Requirements Document template
- `~/.claude/docs/specs/techspec-template.md` - Technical Specification template
- `~/.claude/docs/specs/tasks-template.md` - Tasks breakdown template

**Template Format**: Templates should be markdown files with placeholders and structure that commands will use to generate feature-specific documents.

**Setup**: Ensure these templates exist before running feature-marker:
```bash
ls ~/.claude/docs/specs/
# Should show: prd-template.md, techspec-template.md, tasks-template.md
```

**Note**: If templates are missing, commands in `~/.claude/commands/` will fail to generate files.

### Project Structure

**Feature Documents** (generated in project):
```
./tasks/
‚îî‚îÄ‚îÄ prd-{feature-name}/
    ‚îú‚îÄ‚îÄ prd.md            ‚Üê Generated from ~/.claude/docs/specs/prd-template.md
    ‚îú‚îÄ‚îÄ techspec.md       ‚Üê Generated from ~/.claude/docs/specs/techspec-template.md
    ‚îú‚îÄ‚îÄ tasks.md          ‚Üê Generated from ~/.claude/docs/specs/tasks-template.md
    ‚îî‚îÄ‚îÄ {num}_task.md     ‚Üê Individual task files (optional)
```

**State Directory** (checkpoint & progress):
```
.claude/feature-state/{feature-name}/
‚îú‚îÄ‚îÄ checkpoint.json
‚îú‚îÄ‚îÄ analysis.md
‚îú‚îÄ‚îÄ plan.md
‚îú‚îÄ‚îÄ progress.md
‚îú‚îÄ‚îÄ test-results.md
‚îî‚îÄ‚îÄ pr-url.txt
```

**User Configuration** (required setup):
```
~/.claude/
‚îú‚îÄ‚îÄ commands/           ‚Üê Commands that generate files
‚îÇ   ‚îú‚îÄ‚îÄ create-prd.md
‚îÇ   ‚îú‚îÄ‚îÄ generate-spec.md
‚îÇ   ‚îî‚îÄ‚îÄ generate-tasks.md
‚îî‚îÄ‚îÄ docs/
    ‚îî‚îÄ‚îÄ specs/          ‚Üê Templates used by commands
        ‚îú‚îÄ‚îÄ prd-template.md
        ‚îú‚îÄ‚îÄ techspec-template.md
        ‚îî‚îÄ‚îÄ tasks-template.md
```

## Behavior

When invoked, the skill:

1. **Validates inputs** - Checks if `./tasks/prd-{feature-slug}/` contains required files
   - If all files exist ‚Üí Skips to step 3
   - If any file is missing ‚Üí Proceeds to step 2
2. **Generates ONLY missing files** - Existing files are never overwritten:
   - Missing PRD ‚Üí `/create-prd`
   - Missing Tech Spec ‚Üí `/generate-spec {feature-slug}`
   - Missing Tasks ‚Üí `/generate-tasks {feature-slug}`
3. **Auto-installs missing dependencies**:
   - **Phase 1**: Checks for `product-manager` skill
     - If missing: Installs via `npx skills add https://github.com/aj-geddes/claude-code-bmad-skills --skill product-manager`
     - If user already has it: Uses user's version
     - If installation fails: Continues without it (non-blocking)
   - **Phase 4**: Checks for `/commit` command
     - If missing: Copies from bundled `resources/commit.md` to `~/.claude/commands/commit.md`
     - If user already has it: Uses user's version
     - If installation fails: Falls back to standard commit workflow
4. **Executes 5-phase workflow** via the `feature-marker` agent
5. **Persists state** - Saves checkpoints after each phase/task for resume capability

**Important**: The workflow is smart about file detection and dependencies:
- ‚úÖ Files/skills/commands exist ‚Üí Uses them directly, no regeneration or reinstallation
- ‚ö†Ô∏è Missing ‚Üí Installs/generates only what's needed
- üîí Never overwrites existing content
- üë§ **User's versions always have priority** over bundled/auto-installed versions

## Auto-Installed Dependencies

Feature-marker automatically installs missing dependencies to enhance the workflow:

### Product Manager Skill (Phase 1)

**What it does**: Provides advanced PRD analysis, requirements validation, and product management capabilities.

**Installation**:
- **Check**: Phase 1 checks for `~/.claude/skills/product-manager/SKILL.md`
- **Install**: If missing and `npx` available, runs:
  ```bash
  npx skills add https://github.com/aj-geddes/claude-code-bmad-skills --skill product-manager
  ```
- **Priority**: Uses user's existing skill if already installed
- **Fallback**: Continues without it if installation fails (non-blocking)

**Benefits**:
- Enhanced requirement analysis
- Better PRD validation
- Improved feature planning

### Enhanced Commit Command (Phase 4)

**What it does**: Professional commit workflow with validation, splitting, and conventional commit format.

**Installation**:
- **Check**: Phase 4 checks for `~/.claude/commands/commit.md`
- **Install**: If missing, copies from bundled `resources/commit.md` to `~/.claude/commands/commit.md`
- **Priority**: Uses user's existing command if already installed
- **Fallback**: Uses standard commit workflow if installation fails

**Features**:
- Pre-commit validation (lint, build, docs)
- Intelligent commit splitting
- Conventional commit format with emojis
- Smart file staging
- No Co-Authored-By footer (as per command design)

**Example Output**:
```bash
‚ú® feat: add user authentication system
üêõ fix: resolve memory leak in rendering process
üìù docs: update API documentation
‚ôªÔ∏è refactor: simplify error handling logic
```

### Manual Installation

If auto-installation fails, you can install manually:

**Product Manager Skill**:
```bash
npx skills add https://github.com/aj-geddes/claude-code-bmad-skills --skill product-manager
```

**Commit Command**:
```bash
cp ~/.claude/skills/feature-marker/resources/commit.md ~/.claude/commands/commit.md
```

## Template Setup Guide

### Template Directory Structure

Commands in `~/.claude/commands/` read templates from a centralized location:

```
~/.claude/docs/specs/
‚îú‚îÄ‚îÄ prd-template.md          # Product Requirements Document template
‚îú‚îÄ‚îÄ techspec-template.md     # Technical Specification template
‚îî‚îÄ‚îÄ tasks-template.md        # Task breakdown template
```

### Why Templates in ~/.claude/docs/specs?

- **Centralized**: All projects share the same templates
- **User-controlled**: Users can customize their own templates
- **Portable**: Commands reference templates via standard path
- **Separation**: Templates are not in project repositories

### Template Content

Each template should be a markdown file with:
- Clear section structure
- Placeholder text or variables
- Examples and formatting guidelines

Commands read these templates and populate them with feature-specific content.

### Setup Verification

To verify your setup is complete:

```bash
# Check templates exist
ls -l ~/.claude/docs/specs/

# Check commands exist
ls -l ~/.claude/commands/

# Test feature-marker
/feature-marker --interactive prd-test-feature
```

If templates are missing, create them in `~/.claude/docs/specs/` before running feature-marker.

## Checkpoint & Resume

If interrupted (Ctrl+C, session crash, etc.), re-invoke with the same feature slug to resume:

```
/feature-marker prd-user-authentication
```

The skill will:
- Detect existing checkpoint
- Show current progress (phase, task index)
- Ask if you want to resume or start fresh

## Platform Detection

In Phase 4, the skill auto-detects your git platform and selects the appropriate PR skill:

| Platform | Detection | PR Skill |
|----------|-----------|----------|
| GitHub | `github.com` in remote URL | `checking-pr` |
| Azure DevOps | `dev.azure.com` in remote URL | `azure-pr` |
| GitLab | `gitlab.com` in remote URL | `checking-pr` |
| Bitbucket | `bitbucket.org` in remote URL | `checking-pr` |
| Other | (fallback) | `checking-pr` |

## Configuration

Override default behavior with `.feature-marker.json` in your repository root:

```json
{
  "pr_skill": "custom-pr-skill",
  "skip_pr": false,
  "test_command": "npm run test:ci",
  "docs_path": "./tasks",
  "state_path": ".claude/feature-state"
}
```

## Error Handling

| Scenario | Behavior |
|----------|----------|
| Missing files | Auto-generate via commands |
| No git repo | Fail early with helpful message |
| No tests | Skip Phase 3 with warning |
| Test failures | Report issues, allow fix, offer retry |
| Unknown platform | Fallback to `checking-pr` |
| PR skill unavailable | Commit only, log manual instructions |

## Example Sessions

### Example 1: All Files Exist (No Generation Needed)
```
> /feature-marker prd-user-authentication

Checking for existing checkpoint...
No checkpoint found. Starting new workflow.

Phase 0: Inputs Gate
‚úì prd.md exists
‚úì techspec.md exists
‚úì tasks.md exists
‚úÖ All files present. Skipping generation.

Phase 1: Analysis & Planning
Reading existing documents...
Creating implementation plan...
Checkpoint saved.

Phase 2: Implementation
[1/6] Create User entity... ‚úì
[2/6] Add authentication service... ‚úì
...
```

### Example 2: Partial Files (Generates Only Missing)
```
> /feature-marker prd-payment-integration

Checking for existing checkpoint...
No checkpoint found. Starting new workflow.

Phase 0: Inputs Gate
‚úì prd.md exists
‚úó techspec.md missing ‚Üí Generating via /generate-spec...
‚úì tasks.md exists

‚úÖ Generated missing file. All inputs ready.

Phase 1: Analysis & Planning
Reading documents...
Creating implementation plan...
Checkpoint saved.
...
```

### Example 3: Complete Workflow with Auto-Install
```
> /feature-marker prd-new-feature

Phase 0: Inputs Gate
‚úó prd.md missing ‚Üí Generating via /create-prd...
‚úó techspec.md missing ‚Üí Generating via /generate-spec...
‚úó tasks.md missing ‚Üí Generating via /generate-tasks...

Phase 1: Analysis & Planning
‚öôÔ∏è  Installing product-manager skill...
‚úì product-manager skill installed successfully
Reading PRD, Tech Spec, and Tasks...
Creating implementation plan...
Checkpoint saved.

Phase 2: Implementation
[1/6] Create User entity... ‚úì
[2/6] Add authentication service... ‚úì
[3/6] Implement login endpoint... ‚úì
[4/6] Add JWT token handling... ‚úì
[5/6] Create logout endpoint... ‚úì
[6/6] Add session management... ‚úì
Checkpoint saved.

Phase 3: Tests & Validation
Running: swift test
All tests passed.
Checkpoint saved.

Phase 4: Commit & PR
‚öôÔ∏è  Installing commit command...
‚úì commit command installed successfully
Using enhanced commit workflow (/commit)...
‚ú® feat: implement user authentication system
Detected platform: GitHub
Creating PR via /checking-pr...

‚úì Feature complete!
PR URL: https://github.com/user/repo/pull/42
```

### Example 4: Using Existing User Tools
```
> /feature-marker prd-payment-feature

Phase 0: Inputs Gate
‚úì All inputs validated.

Phase 1: Analysis & Planning
‚úì product-manager skill already installed (using user's version)
...

Phase 4: Commit & PR
‚úì commit command already exists (using user's version)
...
```


ARGUMENTS: --interactive -prd-bugfix-descriptionExercices